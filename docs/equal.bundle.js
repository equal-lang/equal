/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var equal;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/equal/big-lexer.ts":
/*!********************************!*\
  !*** ./src/equal/big-lexer.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.BigToken = exports.bigLexer = void 0;\r\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/equal/error.ts\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/equal/utils.ts\");\r\nfunction bigLexer(tokens, path, errHandler) {\r\n    var bigTokens = [];\r\n    var pointer = 0;\r\n    var startTag = [], text = [], endTag = [];\r\n    var inStartTag = false, inEndTag = false;\r\n    while (pointer <= tokens.length - 1) {\r\n        var token = tokens[pointer];\r\n        if (token[\"tokenType\"] == \"START_TAG_LEFT\" /* tokenType.START_TAG_LEFT */) {\r\n            evalText(text);\r\n            if (inStartTag)\r\n                throwError(\"Unterminated start tag\", token[\"line\"]);\r\n            inStartTag = true;\r\n        }\r\n        else if (token[\"tokenType\"] == \"END_TAG_LEFT\" /* tokenType.END_TAG_LEFT */) {\r\n            evalText(text);\r\n            if (inEndTag)\r\n                throwError(\"Unterminated end tag\", token[\"line\"]);\r\n            inEndTag = true;\r\n        }\r\n        else if (token[\"tokenType\"] == \"TAG_RIGHT\" /* tokenType.TAG_RIGHT */) {\r\n            if (inStartTag && inEndTag)\r\n                throwError(\"Missing right tag\", token[\"line\"]);\r\n            else if (!inStartTag && !inEndTag)\r\n                throwError(\"Extra right tag\", token[\"line\"]);\r\n            else if (inStartTag) {\r\n                evalStartTag(startTag);\r\n                inStartTag = false;\r\n            }\r\n            else if (inEndTag) {\r\n                evalEndTag(endTag);\r\n                inEndTag = false;\r\n            }\r\n        }\r\n        else if (token[\"tokenType\"] == \"EOF\" /* tokenType.EOF */) {\r\n            // only a value?\r\n            evalText(text);\r\n        }\r\n        else {\r\n            if (inStartTag)\r\n                startTag.push(token);\r\n            else if (inEndTag)\r\n                endTag.push(token);\r\n            else\r\n                text.push(token);\r\n        }\r\n        pointer++;\r\n    }\r\n    if (inStartTag || inEndTag)\r\n        reportError(\"Unclosed tag\", tokens[tokens.length - 1][\"line\"]);\r\n    // test for this\r\n    // EOF?\r\n    return bigTokens;\r\n    function evalStartTag(arr) {\r\n        if (arr.length == 0)\r\n            return;\r\n        startTag = [];\r\n        var tagName = arr[0][\"value\"];\r\n        if (!tagName)\r\n            throwError(\"Missing tagname\", arr[0][\"line\"]);\r\n        var attributeList = tagMap.get(tagName);\r\n        if (attributeList == undefined)\r\n            return;\r\n        var attribute = {};\r\n        var pos = 1;\r\n        var currentAttr = \"\", currentVal = \"\";\r\n        while (pos < arr.length) {\r\n            if (arr[pos] && arr[pos][\"tokenType\"] == \"ATTRIBUTE\" /* tokenType.ATTRIBUTE */ && attributeList.includes(arr[pos][\"value\"])) {\r\n                currentAttr = arr[pos][\"value\"];\r\n                pos++;\r\n                if (arr[pos] && arr[pos][\"tokenType\"] == \"EQUAL_SIGN\" /* tokenType.EQUAL_SIGN */)\r\n                    pos++;\r\n                else\r\n                    throwError(\"Missing equal sign\", arr[pos - 1][\"line\"]);\r\n                // use arr[pos] in the future?\r\n                if (arr[pos] && arr[pos][\"tokenType\"] == \"VALUE\" /* tokenType.VALUE */) {\r\n                    if (arr[pos][\"value\"] == undefined)\r\n                        throwError(\"Undefined value\", arr[pos][\"line\"]);\r\n                    else\r\n                        currentVal = arr[pos][\"value\"];\r\n                    pos++;\r\n                }\r\n                attribute[currentAttr] = currentVal;\r\n                currentAttr = \"\", currentVal = \"\";\r\n            }\r\n            // pos++;\r\n        }\r\n        bigTokens.push(new BigToken(\"START_TAG\" /* bigTokenType.START_TAG */, tagName, attribute, arr[arr.length - 1][\"line\"]));\r\n    }\r\n    function evalEndTag(arr) {\r\n        if (arr.length == 0)\r\n            return;\r\n        endTag = [];\r\n        if (arr.length > 1)\r\n            reportError(\"Extra attributes in end tag\", arr[0][\"line\"]);\r\n        var tagName = arr[0][\"value\"];\r\n        if (!tagName)\r\n            throwError(\"Missing tagname\", arr[0][\"line\"]);\r\n        bigTokens.push(new BigToken(\"END_TAG\" /* bigTokenType.END_TAG */, tagName, {}, arr[0][\"line\"]));\r\n    }\r\n    function evalText(arr) {\r\n        if (arr.length == 0)\r\n            return;\r\n        text = [];\r\n        if (arr.length > 1)\r\n            reportError(\"Extra attributes in text\", arr[0][\"line\"]);\r\n        var val = arr[0][\"value\"];\r\n        if (val === undefined)\r\n            throwError(\"The value of a literal cannot be undefined\", arr[0][\"line\"]);\r\n        bigTokens.push(new BigToken(\"TEXT\" /* bigTokenType.TEXT */, undefined, { \"value\": (0, utils_1.wrapValue)(val) }, arr[0][\"line\"]));\r\n    }\r\n    function throwError(message, line) {\r\n        throw new error_1.EqualSyntaxError(message, path, line);\r\n    }\r\n    function reportError(message, line) {\r\n        var err = new error_1.EqualSyntaxError(message, path, line);\r\n        errHandler.reportError(err);\r\n    }\r\n}\r\nexports.bigLexer = bigLexer;\r\n// tagname -> attributes needed\r\nvar tagMap = new Map()\r\n    .set(\"div\", [])\r\n    .set(\"h1\", [\"class\"])\r\n    .set(\"h2\", [\"class\"])\r\n    .set(\"h3\", [\"class\"])\r\n    .set(\"h4\", [\"class\"])\r\n    .set(\"h5\", [\"class\"])\r\n    .set(\"h6\", [\"class\"])\r\n    .set(\"p\", [\"class\"])\r\n    .set(\"a\", [\"id\", \"href\", \"class\"])\r\n    .set(\"input\", [\"type\", \"value\", \"id\"])\r\n    .set(\"form\", [\"title\", \"id\"])\r\n    .set(\"label\", [\"for\"])\r\n    .set(\"link\", [\"rel\", \"href\", \"type\"])\r\n    // .set(\"img\", [\"src\", \"alt\"])\r\n    .set(\"span\", []);\r\nvar BigToken = /** @class */ (function () {\r\n    function BigToken(type, name, attribute, line) {\r\n        this.type = type;\r\n        this.name = name;\r\n        this.attribute = attribute;\r\n        this.line = line;\r\n    }\r\n    return BigToken;\r\n}());\r\nexports.BigToken = BigToken;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/big-lexer.ts?");

/***/ }),

/***/ "./src/equal/callable.ts":
/*!*******************************!*\
  !*** ./src/equal/callable.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.returnVal = exports.EqualFunction = exports.isEqualCallable = void 0;\r\nvar environment_1 = __webpack_require__(/*! ./environment */ \"./src/equal/environment.ts\");\r\nfunction isEqualCallable(cls) {\r\n    return cls.arity !== undefined && cls.call !== undefined;\r\n}\r\nexports.isEqualCallable = isEqualCallable;\r\nvar EqualFunction = /** @class */ (function () {\r\n    function EqualFunction(declaration) {\r\n        this.declaration = declaration;\r\n    }\r\n    EqualFunction.prototype.arity = function () {\r\n        return this.declaration.params.length;\r\n    };\r\n    EqualFunction.prototype.call = function (interpreter, args) {\r\n        // global functions\r\n        var env = new environment_1.Environment(interpreter.environment);\r\n        for (var pointer = 0; pointer <= args.length - 1; pointer++) {\r\n            env.assign(this.declaration.params[pointer], args[pointer]);\r\n        }\r\n        try {\r\n            interpreter.publicExecBlock(this.declaration.body, env);\r\n        }\r\n        catch (ret) {\r\n            return ret.val;\r\n        }\r\n        return 0;\r\n    };\r\n    return EqualFunction;\r\n}());\r\nexports.EqualFunction = EqualFunction;\r\nvar returnVal = /** @class */ (function (_super) {\r\n    __extends(returnVal, _super);\r\n    function returnVal(val) {\r\n        var _this = _super.call(this) || this;\r\n        Object.setPrototypeOf(_this, returnVal.prototype);\r\n        _this.name = \"returnVal\";\r\n        _this.val = val;\r\n        return _this;\r\n    }\r\n    return returnVal;\r\n}(Error));\r\nexports.returnVal = returnVal;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/callable.ts?");

/***/ }),

/***/ "./src/equal/environment.ts":
/*!**********************************!*\
  !*** ./src/equal/environment.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.Environment = void 0;\r\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/equal/error.ts\");\r\nvar Environment = /** @class */ (function () {\r\n    function Environment(outEnv) {\r\n        this.variables = new Map();\r\n        this.functions = new Map();\r\n        this.outerEnv = outEnv;\r\n    }\r\n    Environment.prototype.assign = function (key, val) {\r\n        this.variables.set(key, val);\r\n    };\r\n    Environment.prototype.get = function (key) {\r\n        var val = this.variables.get(key);\r\n        // precedence: id and href\r\n        // TODO: get file name and line here\r\n        if (val == undefined && this.outerEnv != undefined) {\r\n            val = this.outerEnv.get(key);\r\n        }\r\n        if (val == undefined)\r\n            throw new error_1.EqualRuntimeError(\"Undefined variable \" + key);\r\n        return val;\r\n    };\r\n    Environment.prototype.declareFunc = function (key, func) {\r\n        this.functions.set(key, func);\r\n    };\r\n    Environment.prototype.getFunc = function (key) {\r\n        var func = this.functions.get(key);\r\n        if (func == undefined)\r\n            throw new error_1.EqualRuntimeError(\"Undeclared function \" + key);\r\n        return func;\r\n    };\r\n    return Environment;\r\n}());\r\nexports.Environment = Environment;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/environment.ts?");

/***/ }),

/***/ "./src/equal/equal.ts":
/*!****************************!*\
  !*** ./src/equal/equal.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.Equal = void 0;\r\nvar fs = __webpack_require__(/*! fs */ \"?1fe8\");\r\nvar lexer_1 = __webpack_require__(/*! ./lexer */ \"./src/equal/lexer.ts\");\r\nvar parser_1 = __webpack_require__(/*! ./parser */ \"./src/equal/parser.ts\");\r\nvar interpreter_1 = __webpack_require__(/*! ./interpreter */ \"./src/equal/interpreter.ts\");\r\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/equal/error.ts\");\r\nvar printer_1 = __webpack_require__(/*! ./printer */ \"./src/equal/printer.ts\");\r\nvar Equal = /** @class */ (function () {\r\n    function Equal(_a) {\r\n        var _b = _a.mode, mode = _b === void 0 ? \"NORMAL\" : _b, path = _a.path, source = _a.source, _c = _a.output, output = _c === void 0 ? console.log : _c, input = _a.input;\r\n        // either path or source is required\r\n        // source takes precedence\r\n        try {\r\n            if (mode == \"VERBOSE\")\r\n                this.mode = \"VERBOSE\" /* equalMode.VERBOSE */;\r\n            else\r\n                this.mode = \"NORMAL\" /* equalMode.NORMAL */;\r\n            this.errHandler = new error_1.ErrorHandler(this.mode);\r\n            this.error = false;\r\n            this.printer = new printer_1.Printer(output);\r\n            this.lexer = new lexer_1.Lexer(this.mode, this.errHandler);\r\n            this.parser = new parser_1.Parser(this.mode, this.errHandler);\r\n            this.interpreter = new interpreter_1.Interpreter(this.mode, this.errHandler, this.printer, input);\r\n            if (!path && !source)\r\n                throw new error_1.EqualRuntimeError(\"No source code found\");\r\n            else if (source) {\r\n                this.source = source;\r\n            }\r\n            else if (path) {\r\n                this.source = this.loadFile(path);\r\n            }\r\n            this.path = (path != undefined) ? path : \"Unknown\";\r\n        }\r\n        catch (err) {\r\n            this.errHandler.handleError(err);\r\n        }\r\n    }\r\n    Equal.prototype.run = function () {\r\n        try {\r\n            this.error = this.errHandler.getErrorStatus();\r\n            if (this.error == false) {\r\n                this.verbose(\"Running in verbose mode\");\r\n                var tokens = this.lexer.lex(this.source, this.path);\r\n                this.verbose(tokens, \"Tokens\");\r\n                var ast = this.parser.parse(tokens, this.path);\r\n                this.execute(ast, this.path);\r\n                this.verbose(\"Finished running script\");\r\n                return this.printer.allPrinted();\r\n            }\r\n        }\r\n        catch (err) {\r\n            this.errHandler.handleError(err);\r\n        }\r\n    };\r\n    // always inside another function's try block\r\n    Equal.prototype.loadFile = function (path) {\r\n        this.verbose(\"Loading file at \" + this.path);\r\n        if (!fs.existsSync(path))\r\n            throw new error_1.EqualRuntimeError(\"Invalid path\");\r\n        var file = fs.readFileSync(path, \"utf8\");\r\n        // undefined?\r\n        return file;\r\n    };\r\n    Equal.prototype.execute = function (ast, path) {\r\n        try {\r\n            this.error = this.errHandler.getErrorStatus();\r\n            if (this.error == false) {\r\n                this.interpreter.interpret(ast, path);\r\n                this.printer.flushBuffer();\r\n            }\r\n            else {\r\n                this.verbose(this.errHandler.errors, \"Errors\");\r\n            }\r\n        }\r\n        catch (err) {\r\n            this.errHandler.handleError(err);\r\n        }\r\n    };\r\n    Equal.prototype.verbose = function (log, message) {\r\n        if (this.mode == \"VERBOSE\" /* equalMode.VERBOSE */) {\r\n            if (message)\r\n                console.debug(message, log);\r\n            else\r\n                console.debug(log);\r\n        }\r\n    };\r\n    return Equal;\r\n}());\r\nexports.Equal = Equal;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/equal.ts?");

/***/ }),

/***/ "./src/equal/error.ts":
/*!****************************!*\
  !*** ./src/equal/error.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.ErrorHandler = exports.EqualUnexpectedError = exports.EqualRuntimeError = exports.EqualSyntaxError = exports.EqualError = void 0;\r\nfunction isErrorVisitor(cls) {\r\n    return (cls.visitSyntaxError !== undefined && cls.visitRuntimeError !== undefined && cls.visitUnexpectedError !== undefined);\r\n}\r\nvar ErrorPrinter = /** @class */ (function () {\r\n    function ErrorPrinter() {\r\n    }\r\n    ErrorPrinter.prototype.print = function (err) {\r\n        return err.accept(this);\r\n    };\r\n    ErrorPrinter.prototype.visitSyntaxError = function (host) {\r\n        return \"SyntaxError at \" + this.toString(host);\r\n    };\r\n    ErrorPrinter.prototype.visitRuntimeError = function (host) {\r\n        return \"RuntimeError at \" + this.toString(host);\r\n    };\r\n    ErrorPrinter.prototype.visitUnexpectedError = function (host) {\r\n        return \"Unexpected Error: \" + host.message + \"\\nPlease report the bug at https://github.com/equal-lang/equal/issues\\n(To view the stack trace, run the interpreter again in verbose mode)\";\r\n    };\r\n    ErrorPrinter.prototype.toString = function (err) {\r\n        return err.file + \":\" + err.line + \": \" + err.message;\r\n    };\r\n    return ErrorPrinter;\r\n}());\r\nvar EqualError = /** @class */ (function (_super) {\r\n    __extends(EqualError, _super);\r\n    function EqualError(message, file, line) {\r\n        var _this = _super.call(this, message) || this;\r\n        Object.setPrototypeOf(_this, EqualError.prototype);\r\n        _this.name = \"EqualError\";\r\n        _this.message = message;\r\n        _this.file = ((file == undefined) ? \"Unknown\" : file);\r\n        _this.line = ((line == undefined) ? 0 : line);\r\n        return _this;\r\n    }\r\n    EqualError.prototype.accept = function (visitor) {\r\n        if (!isErrorVisitor(visitor))\r\n            throw new Error(\"Invalid visitor type\");\r\n    };\r\n    return EqualError;\r\n}(Error));\r\nexports.EqualError = EqualError;\r\n// errors that occurred during lexing or parsing\r\nvar EqualSyntaxError = /** @class */ (function (_super) {\r\n    __extends(EqualSyntaxError, _super);\r\n    function EqualSyntaxError(message, file, line) {\r\n        var _this = _super.call(this, message, file, line) || this;\r\n        Object.setPrototypeOf(_this, EqualSyntaxError.prototype);\r\n        _this.name = \"EqualSyntaxError\";\r\n        return _this;\r\n    }\r\n    EqualSyntaxError.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitSyntaxError(this);\r\n    };\r\n    return EqualSyntaxError;\r\n}(EqualError));\r\nexports.EqualSyntaxError = EqualSyntaxError;\r\n// rest of the errors\r\nvar EqualRuntimeError = /** @class */ (function (_super) {\r\n    __extends(EqualRuntimeError, _super);\r\n    function EqualRuntimeError(message, file, line) {\r\n        var _this = _super.call(this, message, file, line) || this;\r\n        Object.setPrototypeOf(_this, EqualRuntimeError.prototype);\r\n        _this.name = \"EqualRuntimeError\";\r\n        return _this;\r\n    }\r\n    EqualRuntimeError.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitRuntimeError(this);\r\n    };\r\n    return EqualRuntimeError;\r\n}(EqualError));\r\nexports.EqualRuntimeError = EqualRuntimeError;\r\n// reserved for errors the interpreter produced\r\nvar EqualUnexpectedError = /** @class */ (function (_super) {\r\n    __extends(EqualUnexpectedError, _super);\r\n    function EqualUnexpectedError(message, file, line) {\r\n        var _this = _super.call(this, message, file, line) || this;\r\n        Object.setPrototypeOf(_this, EqualUnexpectedError.prototype);\r\n        _this.name = \"EqualUnexpectedError\";\r\n        return _this;\r\n    }\r\n    EqualUnexpectedError.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitUnexpectedError(this);\r\n    };\r\n    return EqualUnexpectedError;\r\n}(EqualError));\r\nexports.EqualUnexpectedError = EqualUnexpectedError;\r\nvar ErrorHandler = /** @class */ (function () {\r\n    function ErrorHandler(mode) {\r\n        this.mode = mode;\r\n        this._hasError = false;\r\n        this.errors = [];\r\n    }\r\n    ErrorHandler.prototype.getErrorStatus = function () {\r\n        return this._hasError;\r\n    };\r\n    // Report errors identified without ending parsing\r\n    ErrorHandler.prototype.reportError = function (err) {\r\n        console.error(new ErrorPrinter().print(err));\r\n        this._hasError = true;\r\n        this.errors.push(err);\r\n    };\r\n    // Handle errors that are thrown\r\n    ErrorHandler.prototype.handleError = function (err) {\r\n        // probably will make this output look better\r\n        if (this.mode == \"VERBOSE\" /* equalMode.VERBOSE */)\r\n            console.debug(\"Error\", err);\r\n        var newErr;\r\n        if (!(err instanceof EqualError))\r\n            newErr = new EqualUnexpectedError(err.message);\r\n        else\r\n            newErr = err;\r\n        console.error(new ErrorPrinter().print(newErr));\r\n        this._hasError = true;\r\n        this.errors.push(newErr);\r\n    };\r\n    return ErrorHandler;\r\n}());\r\nexports.ErrorHandler = ErrorHandler;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/error.ts?");

/***/ }),

/***/ "./src/equal/expression.ts":
/*!*********************************!*\
  !*** ./src/equal/expression.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.Call = exports.Variable = exports.Literal = exports.Unary = exports.Logical = exports.Binary = exports.Expression = exports.isExpressionVisitor = void 0;\r\nfunction isExpressionVisitor(cls) {\r\n    return cls.visitBinary !== undefined && cls.visitLogical !== undefined && cls.visitUnary !== undefined && cls.visitLiteral !== undefined && cls.visitVariable !== undefined && cls.visitCall !== undefined;\r\n}\r\nexports.isExpressionVisitor = isExpressionVisitor;\r\n// abstract class\r\nvar Expression = /** @class */ (function () {\r\n    function Expression() {\r\n    }\r\n    Expression.prototype.accept = function (visitor) {\r\n        if (!isExpressionVisitor(visitor))\r\n            throw new Error(\"Invalid visitor type\");\r\n    };\r\n    return Expression;\r\n}());\r\nexports.Expression = Expression;\r\nvar Binary = /** @class */ (function (_super) {\r\n    __extends(Binary, _super);\r\n    function Binary(operator, arg1, arg2) {\r\n        var _this = _super.call(this) || this;\r\n        _this.operator = operator;\r\n        _this.arg1 = arg1;\r\n        _this.arg2 = arg2;\r\n        return _this;\r\n    }\r\n    Binary.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitBinary(this);\r\n    };\r\n    return Binary;\r\n}(Expression));\r\nexports.Binary = Binary;\r\nvar Logical = /** @class */ (function (_super) {\r\n    __extends(Logical, _super);\r\n    function Logical(operator, arg1, arg2) {\r\n        var _this = _super.call(this) || this;\r\n        _this.operator = operator;\r\n        _this.arg1 = arg1;\r\n        _this.arg2 = arg2;\r\n        return _this;\r\n    }\r\n    Logical.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitLogical(this);\r\n    };\r\n    return Logical;\r\n}(Expression));\r\nexports.Logical = Logical;\r\nvar Unary = /** @class */ (function (_super) {\r\n    __extends(Unary, _super);\r\n    function Unary(operator, arg1) {\r\n        var _this = _super.call(this) || this;\r\n        _this.operator = operator;\r\n        _this.arg1 = arg1;\r\n        return _this;\r\n    }\r\n    Unary.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitUnary(this);\r\n    };\r\n    return Unary;\r\n}(Expression));\r\nexports.Unary = Unary;\r\nvar Literal = /** @class */ (function (_super) {\r\n    __extends(Literal, _super);\r\n    function Literal(arg) {\r\n        var _this = _super.call(this) || this;\r\n        _this.arg = arg;\r\n        return _this;\r\n    }\r\n    Literal.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitLiteral(this);\r\n    };\r\n    return Literal;\r\n}(Expression));\r\nexports.Literal = Literal;\r\nvar Variable = /** @class */ (function (_super) {\r\n    __extends(Variable, _super);\r\n    function Variable(name) {\r\n        var _this = _super.call(this) || this;\r\n        _this.name = name;\r\n        return _this;\r\n    }\r\n    Variable.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitVariable(this);\r\n    };\r\n    return Variable;\r\n}(Expression));\r\nexports.Variable = Variable;\r\nvar Call = /** @class */ (function (_super) {\r\n    __extends(Call, _super);\r\n    function Call(calleeName, args) {\r\n        var _this = _super.call(this) || this;\r\n        _this.calleeName = calleeName;\r\n        _this.args = args;\r\n        return _this;\r\n    }\r\n    Call.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitCall(this);\r\n    };\r\n    return Call;\r\n}(Expression));\r\nexports.Call = Call;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/expression.ts?");

/***/ }),

/***/ "./src/equal/interpreter.ts":
/*!**********************************!*\
  !*** ./src/equal/interpreter.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.Interpreter = void 0;\r\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/equal/error.ts\");\r\nvar environment_1 = __webpack_require__(/*! ./environment */ \"./src/equal/environment.ts\");\r\nvar callable_1 = __webpack_require__(/*! ./callable */ \"./src/equal/callable.ts\");\r\nvar Interpreter = /** @class */ (function () {\r\n    function Interpreter(mode, errHandler, printer, input) {\r\n        this.mode = mode;\r\n        this.errHandler = errHandler;\r\n        this.pointer = 0;\r\n        var globalEnv = new environment_1.Environment();\r\n        this.environment = globalEnv;\r\n        this.global = globalEnv;\r\n        this.printer = printer;\r\n        this.input = input;\r\n    }\r\n    Interpreter.prototype.interpret = function (statements, path) {\r\n        this.path = path;\r\n        this.statements = statements;\r\n        // this.global.declareFunc(\"input\", new Input());\r\n        if (this.mode == \"VERBOSE\" /* equalMode.VERBOSE */)\r\n            console.debug(\"Statements\", this.statements);\r\n        while (!(this.pointer > this.statements.length - 1)) {\r\n            var statement = this.statements[this.pointer];\r\n            this.exec(statement);\r\n            this.pointer++;\r\n        }\r\n        if (this.mode == \"VERBOSE\" /* equalMode.VERBOSE */)\r\n            console.debug(\"GlobalEnvironment\", this.environment);\r\n    };\r\n    Interpreter.prototype.visitBinary = function (host) {\r\n        // write custom operators for comparsion\r\n        var arg1 = this.eval(host.arg1);\r\n        var arg2 = this.eval(host.arg2);\r\n        var operator = host.operator;\r\n        switch (operator) {\r\n            case \"EQUAL\" /* operatorType.EQUAL */: {\r\n                return (arg1 === arg2);\r\n                break;\r\n            }\r\n            case \"NOT_EQUAL\" /* operatorType.NOT_EQUAL */: {\r\n                return (arg1 !== arg2);\r\n                break;\r\n            }\r\n            case \"GREATER_THAN\" /* operatorType.GREATER_THAN */: {\r\n                this.checkType(arg1, [\"number\"]);\r\n                this.checkType(arg2, [\"number\"]);\r\n                return (arg1 > arg2);\r\n                break;\r\n            }\r\n            case \"LESSER_THAN\" /* operatorType.LESSER_THAN */: {\r\n                this.checkType(arg1, [\"number\"]);\r\n                this.checkType(arg2, [\"number\"]);\r\n                return (arg1 < arg2);\r\n                break;\r\n            }\r\n            case \"PLUS\" /* operatorType.PLUS */: {\r\n                this.checkType(arg1, [\"number\"]);\r\n                this.checkType(arg2, [\"number\"]);\r\n                return (arg1 + arg2);\r\n                break;\r\n            }\r\n            case \"MINUS\" /* operatorType.MINUS */: {\r\n                this.checkType(arg1, [\"number\"]);\r\n                this.checkType(arg2, [\"number\"]);\r\n                return (arg1 - arg2);\r\n                break;\r\n            }\r\n            case \"MULTIPLY\" /* operatorType.MULTIPLY */: {\r\n                this.checkType(arg1, [\"number\"]);\r\n                this.checkType(arg2, [\"number\"]);\r\n                return (arg1 * arg2);\r\n                break;\r\n            }\r\n            case \"DIVIDE\" /* operatorType.DIVIDE */: {\r\n                this.checkType(arg1, [\"number\"]);\r\n                this.checkType(arg2, [\"number\"]);\r\n                if (arg2 == 0)\r\n                    throw new error_1.EqualRuntimeError(\"Division by zero\", this.path);\r\n                return (arg1 / arg2);\r\n                break;\r\n            }\r\n            default: {\r\n                throw new error_1.EqualRuntimeError(\"Binary operator does not exist\", this.path);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    Interpreter.prototype.visitLogical = function (host) {\r\n        var arg1 = this.eval(host.arg1);\r\n        var arg2;\r\n        var operator = host.operator;\r\n        switch (operator) {\r\n            case \"AND\" /* operatorType.AND */: {\r\n                this.checkType(arg1, [\"boolean\"]);\r\n                if (arg1 === true) {\r\n                    arg2 = this.eval(host.arg2);\r\n                    this.checkType(arg2, [\"boolean\"]);\r\n                    return arg2;\r\n                }\r\n                else\r\n                    return false;\r\n                break;\r\n            }\r\n            case \"OR\" /* operatorType.OR */: {\r\n                this.checkType(arg1, [\"boolean\"]);\r\n                if (arg1 === false) {\r\n                    arg2 = this.eval(host.arg2);\r\n                    this.checkType(arg2, [\"boolean\"]);\r\n                    return arg2;\r\n                }\r\n                else\r\n                    return true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new error_1.EqualRuntimeError(\"Logical operator does not exist\", this.path);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    Interpreter.prototype.visitUnary = function (host) {\r\n        var arg1 = this.eval(host.arg1);\r\n        var operator = host.operator;\r\n        switch (operator) {\r\n            case \"NOT\" /* operatorType.NOT */: {\r\n                this.checkType(arg1, [\"boolean\"]);\r\n                return (!(arg1));\r\n                break;\r\n            }\r\n            default: {\r\n                throw new error_1.EqualRuntimeError(\"Operator does not exist\", this.path);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    Interpreter.prototype.visitCall = function (host) {\r\n        // global function\r\n        var func = this.global.getFunc(host.calleeName);\r\n        if (!(0, callable_1.isEqualCallable)(func))\r\n            throw new error_1.EqualRuntimeError(\"Object is not callable\", this.path);\r\n        var argList = [];\r\n        for (var pointer = 0; pointer <= host.args.length - 1; pointer++) {\r\n            var arg = this.eval(host.args[pointer]);\r\n            this.checkType(arg, [\"string\", \"number\", \"boolean\"]);\r\n            argList.push(arg);\r\n        }\r\n        if (argList.length != func.arity())\r\n            throw new error_1.EqualRuntimeError(\"Expected \" + func.arity() + \" arguments, got \" + argList.length);\r\n        return func.call(this, argList);\r\n    };\r\n    Interpreter.prototype.visitLiteral = function (host) {\r\n        this.checkType(host.arg, [\"string\", \"number\", \"boolean\"]);\r\n        return host.arg;\r\n    };\r\n    Interpreter.prototype.visitVariable = function (host) {\r\n        return this.environment.get(host.name);\r\n    };\r\n    Interpreter.prototype.visitScope = function (host) {\r\n        this.execBlock(host.statements, new environment_1.Environment(this.environment));\r\n    };\r\n    Interpreter.prototype.visitAssignment = function (host) {\r\n        if (host.scope == \"global\")\r\n            this.global.assign(host.name, this.eval(host.expression));\r\n        else\r\n            this.environment.assign(host.name, this.eval(host.expression));\r\n    };\r\n    Interpreter.prototype.visitFunctionDeclaration = function (host) {\r\n        var func = new callable_1.EqualFunction(host);\r\n        // global functions\r\n        this.global.declareFunc(host.name, func);\r\n    };\r\n    Interpreter.prototype.visitReturnStatement = function (host) {\r\n        if (this.environment == this.global)\r\n            throw new error_1.EqualRuntimeError(\"No return statement allowed in global scope\", this.path);\r\n        throw new callable_1.returnVal(this.eval(host.expression));\r\n    };\r\n    Interpreter.prototype.visitExpressionStatement = function (host) {\r\n        this.eval(host.expression);\r\n    };\r\n    Interpreter.prototype.visitConditionalStatement = function (host) {\r\n        var correctNum = -1;\r\n        for (var c = 0; c < host.conditions.length; c++) {\r\n            if (this.eval(host.conditions[c]) === true) {\r\n                correctNum = c;\r\n                break;\r\n            }\r\n        }\r\n        // else statement available\r\n        if (correctNum == -1 && (host.statements.length == host.conditions.length + 1)) {\r\n            correctNum = host.statements.length - 1;\r\n        }\r\n        if (correctNum != -1) {\r\n            for (var pointer = 0; pointer <= host.statements[correctNum].length - 1; pointer++) {\r\n                this.exec(host.statements[correctNum][pointer]);\r\n            }\r\n        }\r\n    };\r\n    Interpreter.prototype.visitLoop = function (host) {\r\n        var cond = this.eval(host.condition);\r\n        while (cond === true) {\r\n            for (var pointer = 0; pointer <= host.statements.length - 1; pointer++) {\r\n                this.exec(host.statements[pointer]);\r\n            }\r\n            cond = this.eval(host.condition);\r\n        }\r\n    };\r\n    Interpreter.prototype.visitPrintStatement = function (host) {\r\n        for (var pointer = 0; pointer <= host.expressions.length - 1; pointer++) {\r\n            this.printer.print(this.eval(host.expressions[pointer]));\r\n        }\r\n    };\r\n    Interpreter.prototype.eval = function (expr) {\r\n        return expr.accept(this);\r\n    };\r\n    Interpreter.prototype.exec = function (stmt) {\r\n        return stmt.accept(this);\r\n    };\r\n    Interpreter.prototype.execBlock = function (stmts, env) {\r\n        var prev = this.environment;\r\n        this.environment = env;\r\n        try {\r\n            for (var pointer = 0; pointer <= stmts.length - 1; pointer++) {\r\n                this.exec(stmts[pointer]);\r\n            }\r\n        }\r\n        catch (err) {\r\n            throw err;\r\n        }\r\n        finally {\r\n            this.environment = prev;\r\n        }\r\n        // because thrown in the middle, never reached this statement\r\n    };\r\n    Interpreter.prototype.checkType = function (val, type) {\r\n        for (var _i = 0, type_1 = type; _i < type_1.length; _i++) {\r\n            var t = type_1[_i];\r\n            if (typeof val == t)\r\n                return true;\r\n        }\r\n        throw new error_1.EqualRuntimeError(\"Unexpected type \" + (typeof val), this.path);\r\n    };\r\n    Interpreter.prototype.publicExecBlock = function (stmts, env) {\r\n        return this.execBlock(stmts, env);\r\n    };\r\n    return Interpreter;\r\n}());\r\nexports.Interpreter = Interpreter;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/interpreter.ts?");

/***/ }),

/***/ "./src/equal/lexer.ts":
/*!****************************!*\
  !*** ./src/equal/lexer.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.Lexer = void 0;\r\nvar token_1 = __webpack_require__(/*! ./token */ \"./src/equal/token.ts\");\r\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/equal/error.ts\");\r\nvar Lexer = /** @class */ (function () {\r\n    function Lexer(mode, errHandler) {\r\n        this.mode = mode;\r\n        this.errHandler = errHandler;\r\n        this.source = \"\";\r\n        this.line = 1;\r\n        this.tokens = [];\r\n        this.leftPointer = 0;\r\n        this.rightPointer = 0;\r\n    }\r\n    Lexer.prototype.lex = function (source, path) {\r\n        var _this = this;\r\n        this.source = source;\r\n        this.path = path;\r\n        // how to deal with syntax errors?\r\n        var inTag = false;\r\n        while (!this.atEnd()) {\r\n            var char = this.source[this.rightPointer];\r\n            this.leftPointer = this.rightPointer;\r\n            switch (char) {\r\n                case \"<\": {\r\n                    if (this.condForward(\"!--\", 3)) {\r\n                        this.rightPointer++;\r\n                        this.comment();\r\n                    }\r\n                    else {\r\n                        if (this.condForward(\"/\")) {\r\n                            this.pushToken(\"END_TAG_LEFT\" /* tokenType.END_TAG_LEFT */);\r\n                        }\r\n                        else {\r\n                            this.pushToken(\"START_TAG_LEFT\" /* tokenType.START_TAG_LEFT */);\r\n                        }\r\n                        inTag = true;\r\n                        this.rightPointer++;\r\n                        this.tagname();\r\n                    }\r\n                    break;\r\n                }\r\n                case \">\": {\r\n                    this.pushToken(\"TAG_RIGHT\" /* tokenType.TAG_RIGHT */);\r\n                    inTag = false;\r\n                    // this.rightPointer++;\r\n                    break;\r\n                }\r\n                case \"=\": {\r\n                    if (inTag) {\r\n                        this.pushToken(\"EQUAL_SIGN\" /* tokenType.EQUAL_SIGN */);\r\n                        this.rightPointer++;\r\n                        this.value();\r\n                    }\r\n                    break;\r\n                }\r\n                case \"/\": {\r\n                    if (inTag && this.lookAhead() == \">\")\r\n                        this.rightPointer++;\r\n                    break;\r\n                }\r\n                case \"\\n\": {\r\n                    this.line++;\r\n                    break;\r\n                }\r\n                case \" \":\r\n                case \"\\t\":\r\n                case \"\\r\": {\r\n                    break;\r\n                }\r\n                default: {\r\n                    if (inTag)\r\n                        this.pushToken(\"ATTRIBUTE\" /* tokenType.ATTRIBUTE */, (this.consumeWhile(function (char) { return (char != \"=\" && !_this.endOfTag(char) && !_this.isWhitespace(char)); })));\r\n                    else\r\n                        this.pushToken(\"TEXT\" /* tokenType.TEXT */, this.consumeWhile(function (char) { return (char != \"<\"); }).trim());\r\n                    break;\r\n                }\r\n            }\r\n            this.rightPointer++;\r\n        }\r\n        this.pushToken(\"EOF\" /* tokenType.EOF */);\r\n        return this.tokens;\r\n    };\r\n    Lexer.prototype.tagname = function () {\r\n        var _this = this;\r\n        this.pushToken(\"TAGNAME\" /* tokenType.TAGNAME */, this.consumeWhile(function (char) { return (!_this.isWhitespace(char) && !_this.endOfTag(char)); }));\r\n    };\r\n    // using pointers to slice off quotes\r\n    Lexer.prototype.value = function () {\r\n        var _this = this;\r\n        var firstChar = this.source[this.rightPointer];\r\n        var source;\r\n        if (this.isWhitespace(firstChar)) {\r\n            this.consumeWhile(function (char) { return (_this.isWhitespace(char)); });\r\n            this.rightPointer++;\r\n            firstChar = this.source[this.rightPointer];\r\n        }\r\n        if (firstChar == \"\\\"\") {\r\n            this.rightPointer++;\r\n            source = this.consumeWhile(function (char) { return (char != \"\\\"\"); });\r\n            this.rightPointer++;\r\n        }\r\n        else if (firstChar == \"'\") {\r\n            this.rightPointer++;\r\n            source = this.consumeWhile(function (char) { return (char != \"'\"); });\r\n            this.rightPointer++;\r\n        }\r\n        else {\r\n            source = this.consumeWhile(function (char) { return (!_this.isWhitespace(char) && !_this.endOfTag(char)); });\r\n        }\r\n        this.pushToken(\"VALUE\" /* tokenType.VALUE */, source);\r\n        // this.numberOrString(source);\r\n    };\r\n    Lexer.prototype.comment = function () {\r\n        var _this = this;\r\n        // consumed\r\n        this.consumeWhile(function (char) {\r\n            return (!(char == \"-\" && _this.condForward(\"->\", 2)));\r\n        });\r\n        // really consuming three characters\r\n        this.rightPointer++;\r\n    };\r\n    Lexer.prototype.handleNewline = function () {\r\n        var char = this.source[this.rightPointer];\r\n        if (char == \"\\r\")\r\n            this.line++;\r\n        if (char == \"\\n\" && this.lookBehind() != \"\\r\")\r\n            this.line++;\r\n    };\r\n    // consume and return string while function returns true\r\n    // rely on calling function to move pointer to start of string\r\n    // pointer returned to the end of string to be advanced by the while loop above\r\n    Lexer.prototype.consumeWhile = function (test) {\r\n        // this.rightPointer++;\r\n        this.leftPointer = this.rightPointer;\r\n        var char = this.source[this.rightPointer];\r\n        var testResult = test(char);\r\n        while (!this.atEnd() && testResult) {\r\n            this.handleNewline();\r\n            this.rightPointer++;\r\n            char = this.source[this.rightPointer];\r\n            testResult = test(char);\r\n        }\r\n        // if (testResult) this.reportError(\"Unexpected EOF\");\r\n        // multi-line string: use line number at the end of the string\r\n        var ret = this.source.slice(this.leftPointer, this.rightPointer);\r\n        this.rightPointer--;\r\n        return ret;\r\n    };\r\n    Lexer.prototype.condForward = function (char, offset) {\r\n        if (offset === void 0) { offset = 1; }\r\n        if (!this.atEnd(offset) && char == this.source.slice(this.rightPointer + 1, this.rightPointer + offset + 1)) {\r\n            this.rightPointer += offset;\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    };\r\n    Lexer.prototype.lookAhead = function (offset) {\r\n        if (offset === void 0) { offset = 1; }\r\n        if (!this.atEnd(offset))\r\n            return this.source.slice(this.rightPointer + 1, this.rightPointer + offset + 1);\r\n        else\r\n            return \"\";\r\n    };\r\n    Lexer.prototype.lookBehind = function () {\r\n        if (!this.atEnd(-1))\r\n            return this.source[this.rightPointer - 1];\r\n        else\r\n            return \"\";\r\n    };\r\n    Lexer.prototype.atEnd = function (offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        return (this.rightPointer + offset > this.source.length - 1);\r\n    };\r\n    Lexer.prototype.isWhitespace = function (char) {\r\n        return (char == \" \" || char == \"\\t\" || char == \"\\r\");\r\n    };\r\n    Lexer.prototype.endOfTag = function (char) {\r\n        return (char == \">\" || (char == \"/\" && this.lookAhead() == \">\"));\r\n    };\r\n    Lexer.prototype.pushToken = function (type, value) {\r\n        this.tokens.push(new token_1.Token(type, this.line, value));\r\n    };\r\n    Lexer.prototype.reportError = function (message) {\r\n        var err = new error_1.EqualSyntaxError(message, this.path, this.line);\r\n        this.errHandler.reportError(err);\r\n    };\r\n    return Lexer;\r\n}());\r\nexports.Lexer = Lexer;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/lexer.ts?");

/***/ }),

/***/ "./src/equal/parser.ts":
/*!*****************************!*\
  !*** ./src/equal/parser.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.Parser = void 0;\r\nvar token_1 = __webpack_require__(/*! ./token */ \"./src/equal/token.ts\");\r\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/equal/error.ts\");\r\nvar expression_1 = __webpack_require__(/*! ./expression */ \"./src/equal/expression.ts\");\r\nvar statement_1 = __webpack_require__(/*! ./statement */ \"./src/equal/statement.ts\");\r\nvar big_lexer_1 = __webpack_require__(/*! ./big-lexer */ \"./src/equal/big-lexer.ts\");\r\nvar Parser = /** @class */ (function () {\r\n    function Parser(mode, errHandler) {\r\n        this.mode = mode;\r\n        this.errHandler = errHandler;\r\n        this.pointer = 0;\r\n        this.statements = [];\r\n    }\r\n    Parser.prototype.parse = function (tokens, path) {\r\n        this.path = path;\r\n        this.tokens = (0, big_lexer_1.bigLexer)(tokens, this.path, this.errHandler);\r\n        if (this.mode == \"VERBOSE\" /* equalMode.VERBOSE */)\r\n            console.debug(\"bigTokens\", this.tokens);\r\n        while (!this.atEnd()) {\r\n            this.statements.push(this.statement());\r\n            // this.pointer++;\r\n        }\r\n        return this.statements;\r\n    };\r\n    Parser.prototype.statement = function () {\r\n        return this.scope();\r\n    };\r\n    Parser.prototype.scope = function () {\r\n        if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"div\", {})) {\r\n            var statements = [];\r\n            while (!this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"div\", {})) {\r\n                statements.push(this.statement());\r\n            }\r\n            return new statement_1.Scope(statements);\r\n            // this.force(() => this.match(bigTokenType.END_TAG, \"div\", {}));\r\n        }\r\n        else {\r\n            return this.assignment();\r\n        }\r\n    };\r\n    Parser.prototype.assignment = function () {\r\n        var _this = this;\r\n        if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"a\", {})) {\r\n            var name_1 = this.retPrevAttrE(\"id\");\r\n            var scope = (this.retPrevAttr(\"class\") == \"global\") ? \"global\" : undefined;\r\n            this.checkString(name_1, \"a id\");\r\n            var expr = this.expression();\r\n            this.force(function () { return _this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"a\", {}); });\r\n            return new statement_1.Assignment(name_1, expr, scope);\r\n        }\r\n        else {\r\n            return this.functionDeclaration();\r\n        }\r\n    };\r\n    // add another function to avoid manipulating the pointer\r\n    Parser.prototype.functionDeclaration = function () {\r\n        var _this = this;\r\n        if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"form\", { \"id\": undefined })) {\r\n            var name_2 = this.retPrevAttrE(\"id\");\r\n            this.checkString(name_2, \"function name\");\r\n            var params = [];\r\n            while (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"input\", {})) {\r\n                var id = this.retPrevAttrE(\"id\");\r\n                this.checkString(id, \"input id\");\r\n                params.push(id);\r\n            }\r\n            var statements = [];\r\n            this.force(function () { return _this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"div\", {}); });\r\n            while (!this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"div\", {})) {\r\n                statements.push(this.statement());\r\n            }\r\n            this.force(function () { return _this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"form\", {}); });\r\n            return new statement_1.FunctionDeclaration(name_2, params, statements);\r\n        }\r\n        else\r\n            return this.returnStatement();\r\n    };\r\n    Parser.prototype.returnStatement = function () {\r\n        if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"input\", { \"type\": [\"submit\"] })) {\r\n            return new statement_1.ReturnStatement(this.expression());\r\n        }\r\n        else\r\n            return this.loop();\r\n    };\r\n    Parser.prototype.loop = function () {\r\n        if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"p\", {})) {\r\n            var statements = [];\r\n            var condition = this.expression();\r\n            while (!this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"p\", {})) {\r\n                statements.push(this.statement());\r\n            }\r\n            return new statement_1.Loop(condition, statements);\r\n        }\r\n        else\r\n            return this.conditionalStatement();\r\n    };\r\n    Parser.prototype.conditionalStatement = function () {\r\n        if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"h1\", {})) {\r\n            var statements = [];\r\n            var conditions = [];\r\n            var stmts = [];\r\n            var expr = this.expression();\r\n            while (!this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"h1\", {})) {\r\n                stmts.push(this.statement());\r\n            }\r\n            statements.push(stmts);\r\n            conditions.push(expr);\r\n            // rewrite to avoid repeating?\r\n            for (var i = 2; i <= 5; i++) {\r\n                if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"h\" + i, {})) {\r\n                    expr = this.expression();\r\n                    stmts = [];\r\n                    while (!this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"h\" + i, {})) {\r\n                        stmts.push(this.statement());\r\n                    }\r\n                    statements.push(stmts);\r\n                    conditions.push(expr);\r\n                }\r\n            }\r\n            if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"h6\", {})) {\r\n                stmts = [];\r\n                while (!this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"h6\", {})) {\r\n                    stmts.push(this.statement());\r\n                }\r\n                statements.push(stmts);\r\n            }\r\n            return new statement_1.ConditionalStatement(conditions, statements);\r\n        }\r\n        else {\r\n            return this.printStatement();\r\n        }\r\n    };\r\n    Parser.prototype.printStatement = function () {\r\n        var expressions = [];\r\n        if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"span\", {})) {\r\n            while (!this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"span\", {})) {\r\n                expressions.push(this.expression());\r\n            }\r\n            return new statement_1.PrintStatement(expressions);\r\n        }\r\n        else\r\n            return this.expressionStatement();\r\n    };\r\n    Parser.prototype.expressionStatement = function () {\r\n        return new statement_1.ExpressionStatement(this.expression());\r\n    };\r\n    Parser.prototype.expression = function () {\r\n        return this.logic();\r\n    };\r\n    Parser.prototype.logic = function () {\r\n        return this.retNestedLogicalExpr([\"&&\", \"||\"], this.equality.bind(this));\r\n    };\r\n    Parser.prototype.equality = function () {\r\n        return this.retBinaryExpr([\"==\", \"!=\"], this.comparsion.bind(this));\r\n    };\r\n    Parser.prototype.comparsion = function () {\r\n        return this.retBinaryExpr([\">\", \"<\"], this.addition.bind(this));\r\n    };\r\n    Parser.prototype.addition = function () {\r\n        return this.retNestedBinaryExpr([\"+\", \"-\"], this.multiplication.bind(this));\r\n    };\r\n    Parser.prototype.multiplication = function () {\r\n        return this.retNestedBinaryExpr([\"*\", \"/\"], this.unary.bind(this));\r\n    };\r\n    Parser.prototype.unary = function () {\r\n        if (this.matchStartForm([\"!\"])) {\r\n            var operator = this.retOperator();\r\n            this.force(this.matchStartLabel);\r\n            var base = this.expression();\r\n            this.force(this.matchEndLabel);\r\n            this.force(this.matchEndForm);\r\n            return new expression_1.Unary(operator, base);\r\n        }\r\n        else {\r\n            return this.call();\r\n        }\r\n    };\r\n    Parser.prototype.call = function () {\r\n        if (this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"form\", {})) {\r\n            var calleeName = this.retPrevAttrE(\"title\");\r\n            this.checkString(calleeName, \"callee name\");\r\n            var args = [];\r\n            if (this.matchStartLabel()) {\r\n                while (!this.matchEndLabel()) {\r\n                    var arg = this.expression();\r\n                    args.push(arg);\r\n                }\r\n            }\r\n            this.force(this.matchEndForm);\r\n            return new expression_1.Call(calleeName, args);\r\n        }\r\n        else\r\n            return this.primary();\r\n    };\r\n    Parser.prototype.primary = function () {\r\n        var _this = this;\r\n        if (this.matchText())\r\n            return new expression_1.Literal(this.retPrevAttrE(\"value\"));\r\n        else {\r\n            this.force(function () { return _this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"a\", {}); });\r\n            // if (this.retPrevAttr(\"id\") !== undefined) this.throwError(\"Href and id cannot be used in the same a tag\", this.tokens[this.pointer][\"line\"]);\r\n            var name_3 = this.retPrevAttrE(\"href\");\r\n            this.checkString(name_3, \"a href\");\r\n            this.force(function () { return _this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"a\", {}); });\r\n            return new expression_1.Variable(name_3);\r\n        }\r\n    };\r\n    Parser.prototype.retBinaryExpr = function (operatorList, next) {\r\n        if (this.matchStartForm(operatorList)) {\r\n            var operator = this.retOperator();\r\n            this.force(this.matchStartLabel);\r\n            var base1 = this.expression();\r\n            this.force(this.matchEndLabel);\r\n            this.force(this.matchStartLabel);\r\n            var base2 = this.expression();\r\n            this.force(this.matchEndLabel);\r\n            this.force(this.matchEndForm);\r\n            return new expression_1.Binary(operator, base1, base2);\r\n        }\r\n        else {\r\n            return next();\r\n        }\r\n    };\r\n    Parser.prototype.retNestedExpr = function (operatorList, next, cls) {\r\n        if (this.matchStartForm(operatorList)) {\r\n            var operator = this.retOperator();\r\n            this.force(this.matchStartLabel);\r\n            var base1 = this.expression();\r\n            this.force(this.matchEndLabel);\r\n            this.force(this.matchStartLabel);\r\n            var base2 = this.expression();\r\n            this.force(this.matchEndLabel);\r\n            var base = new cls(operator, base1, base2);\r\n            while (this.matchStartLabel()) {\r\n                var top_1 = this.expression();\r\n                base = new cls(operator, base, top_1);\r\n                this.force(this.matchEndLabel);\r\n            }\r\n            this.force(this.matchEndForm);\r\n            return base;\r\n        }\r\n        else {\r\n            return next();\r\n            // precedence only decide which order expressions are tested in \r\n        }\r\n    };\r\n    Parser.prototype.retNestedBinaryExpr = function (operatorList, next) {\r\n        return this.retNestedExpr(operatorList, next, expression_1.Binary);\r\n    };\r\n    Parser.prototype.retNestedLogicalExpr = function (operatorList, next) {\r\n        return this.retNestedExpr(operatorList, next, expression_1.Logical);\r\n    };\r\n    Parser.prototype.match = function (type, name, attributeObj) {\r\n        var token;\r\n        if (!this.atEnd())\r\n            token = this.tokens[this.pointer];\r\n        else {\r\n            return false;\r\n        }\r\n        if (token[\"type\"] === type && token[\"name\"] === name) {\r\n            for (var item in attributeObj) {\r\n                if (attributeObj[item] == undefined) {\r\n                    if (!token[\"attribute\"][item])\r\n                        return false;\r\n                }\r\n                else if (!attributeObj[item].includes(token[\"attribute\"][item]))\r\n                    return false;\r\n            }\r\n            this.pointer++;\r\n            return true;\r\n        }\r\n        // console.log(type, name, attributeObj);\r\n        return false;\r\n    };\r\n    Parser.prototype.matchStartForm = function (title) {\r\n        return this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"form\", { \"title\": title });\r\n    };\r\n    Parser.prototype.matchStartLabel = function () {\r\n        return this.match(\"START_TAG\" /* bigTokenType.START_TAG */, \"label\", {});\r\n    };\r\n    Parser.prototype.matchText = function () {\r\n        return this.match(\"TEXT\" /* bigTokenType.TEXT */, undefined, {});\r\n    };\r\n    Parser.prototype.matchEndLabel = function () {\r\n        return this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"label\", {});\r\n    };\r\n    Parser.prototype.matchEndForm = function () {\r\n        return this.match(\"END_TAG\" /* bigTokenType.END_TAG */, \"form\", {});\r\n    };\r\n    Parser.prototype.force = function (func) {\r\n        if (!func.bind(this)()) {\r\n            if (this.pointer > this.tokens.length - 1)\r\n                this.throwError(\"Unexpected EOF\", this.tokens[this.tokens.length - 1][\"line\"]);\r\n            var token = this.tokens[this.pointer];\r\n            // better to get what is trying to match from the match function somehow\r\n            var text = void 0;\r\n            if (token[\"type\"] == \"START_TAG\" /* bigTokenType.START_TAG */)\r\n                text = \"start \" + token[\"name\"];\r\n            else if (token[\"type\"] == \"END_TAG\" /* bigTokenType.END_TAG */)\r\n                text = \"end \" + token[\"name\"];\r\n            else\r\n                text = \"text\";\r\n            this.throwError(\"Unexpected \" + text, this.tokens[this.pointer][\"line\"]);\r\n        }\r\n        return true;\r\n    };\r\n    Parser.prototype.retPrevAttr = function (attribute) {\r\n        return this.tokens[this.pointer - 1][\"attribute\"][attribute];\r\n    };\r\n    Parser.prototype.retPrevAttrE = function (attribute) {\r\n        var val = this.retPrevAttr(attribute);\r\n        if (val === undefined) {\r\n            this.throwError(\"Value of attribute \" + attribute + \" cannot be undefined\", this.tokens[this.pointer - 1][\"line\"]);\r\n        }\r\n        return val;\r\n    };\r\n    Parser.prototype.retOperator = function () {\r\n        var operator = token_1.operatorMap.get(this.retPrevAttrE(\"title\"));\r\n        if (operator === undefined)\r\n            this.throwError(\"Operator cannot be undefined\", this.tokens[this.pointer][\"line\"]);\r\n        return operator;\r\n    };\r\n    Parser.prototype.atEnd = function (offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        return (this.pointer + offset > this.tokens.length - 1);\r\n    };\r\n    Parser.prototype.checkString = function (val, name) {\r\n        if (typeof val != \"string\")\r\n            this.throwError(\"String value expected for \" + name, this.tokens[this.pointer][\"line\"]);\r\n    };\r\n    // local error methods\r\n    Parser.prototype.throwError = function (message, line) {\r\n        throw new error_1.EqualSyntaxError(message, this.path, line);\r\n    };\r\n    Parser.prototype.reportError = function (message, line) {\r\n        this.errHandler.reportError(new error_1.EqualSyntaxError(message, this.path, line));\r\n    };\r\n    return Parser;\r\n}());\r\nexports.Parser = Parser;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/parser.ts?");

/***/ }),

/***/ "./src/equal/printer.ts":
/*!******************************!*\
  !*** ./src/equal/printer.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.Printer = void 0;\r\nvar Printer = /** @class */ (function () {\r\n    function Printer(output) {\r\n        this.buffer = \"\";\r\n        this.allText = \"\";\r\n        if (output)\r\n            this.outputMethod = output;\r\n        else\r\n            this.outputMethod = console.log;\r\n    }\r\n    Printer.prototype.print = function (txt) {\r\n        this.outputMethod(txt);\r\n        this.allText += (txt + \"\\n\");\r\n    };\r\n    Printer.prototype.bufferedPrint = function (txt) {\r\n        this.buffer += (txt + \"\\n\");\r\n    };\r\n    Printer.prototype.flushBuffer = function () {\r\n        if (this.buffer) {\r\n            if (this.buffer[this.buffer.length - 1] == \"\\n\")\r\n                this.buffer = this.buffer.slice(0, this.buffer.length - 1);\r\n            this.outputMethod(this.buffer);\r\n        }\r\n    };\r\n    // no verbose logging\r\n    Printer.prototype.allPrinted = function () {\r\n        if (this.allText[this.allText.length - 1] == \"\\n\")\r\n            this.allText = this.allText.slice(0, this.allText.length - 1);\r\n        return this.allText;\r\n    };\r\n    return Printer;\r\n}());\r\nexports.Printer = Printer;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/printer.ts?");

/***/ }),

/***/ "./src/equal/statement.ts":
/*!********************************!*\
  !*** ./src/equal/statement.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.ReturnStatement = exports.FunctionDeclaration = exports.PrintStatement = exports.ExpressionStatement = exports.ConditionalStatement = exports.Loop = exports.Assignment = exports.Scope = exports.Statement = exports.isStatementVisitor = void 0;\r\nfunction isStatementVisitor(cls) {\r\n    return cls.visitScope !== undefined && cls.visitAssignment !== undefined && cls.visitLoop !== undefined && cls.visitConditionalStatement !== undefined && cls.visitExpressionStatement !== undefined && cls.visitPrintStatement !== undefined && cls.visitFunctionDeclaration !== undefined && cls.visitReturnStatement !== undefined;\r\n}\r\nexports.isStatementVisitor = isStatementVisitor;\r\n// abstract class\r\nvar Statement = /** @class */ (function () {\r\n    function Statement() {\r\n    }\r\n    Statement.prototype.accept = function (visitor) {\r\n        if (!isStatementVisitor(visitor))\r\n            throw new Error(\"Invalid visitor type\");\r\n    };\r\n    return Statement;\r\n}());\r\nexports.Statement = Statement;\r\nvar Scope = /** @class */ (function (_super) {\r\n    __extends(Scope, _super);\r\n    function Scope(statements) {\r\n        var _this = _super.call(this) || this;\r\n        _this.statements = statements;\r\n        return _this;\r\n    }\r\n    Scope.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitScope(this);\r\n    };\r\n    return Scope;\r\n}(Statement));\r\nexports.Scope = Scope;\r\nvar Assignment = /** @class */ (function (_super) {\r\n    __extends(Assignment, _super);\r\n    function Assignment(name, expression, scope) {\r\n        var _this = _super.call(this) || this;\r\n        _this.name = name;\r\n        _this.expression = expression;\r\n        _this.scope = scope;\r\n        return _this;\r\n    }\r\n    Assignment.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitAssignment(this);\r\n    };\r\n    return Assignment;\r\n}(Statement));\r\nexports.Assignment = Assignment;\r\nvar Loop = /** @class */ (function (_super) {\r\n    __extends(Loop, _super);\r\n    function Loop(condition, statements) {\r\n        var _this = _super.call(this) || this;\r\n        _this.condition = condition;\r\n        _this.statements = statements;\r\n        return _this;\r\n    }\r\n    Loop.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitLoop(this);\r\n    };\r\n    return Loop;\r\n}(Statement));\r\nexports.Loop = Loop;\r\nvar ConditionalStatement = /** @class */ (function (_super) {\r\n    __extends(ConditionalStatement, _super);\r\n    function ConditionalStatement(conditions, statements) {\r\n        var _this = _super.call(this) || this;\r\n        _this.conditions = conditions;\r\n        _this.statements = statements;\r\n        return _this;\r\n    }\r\n    ConditionalStatement.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitConditionalStatement(this);\r\n    };\r\n    return ConditionalStatement;\r\n}(Statement));\r\nexports.ConditionalStatement = ConditionalStatement;\r\nvar ExpressionStatement = /** @class */ (function (_super) {\r\n    __extends(ExpressionStatement, _super);\r\n    function ExpressionStatement(expression) {\r\n        var _this = _super.call(this) || this;\r\n        _this.expression = expression;\r\n        return _this;\r\n    }\r\n    ExpressionStatement.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitExpressionStatement(this);\r\n    };\r\n    return ExpressionStatement;\r\n}(Statement));\r\nexports.ExpressionStatement = ExpressionStatement;\r\nvar PrintStatement = /** @class */ (function (_super) {\r\n    __extends(PrintStatement, _super);\r\n    function PrintStatement(expressions) {\r\n        var _this = _super.call(this) || this;\r\n        _this.expressions = expressions;\r\n        return _this;\r\n    }\r\n    PrintStatement.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitPrintStatement(this);\r\n    };\r\n    return PrintStatement;\r\n}(Statement));\r\nexports.PrintStatement = PrintStatement;\r\nvar FunctionDeclaration = /** @class */ (function (_super) {\r\n    __extends(FunctionDeclaration, _super);\r\n    function FunctionDeclaration(name, params, body) {\r\n        var _this = _super.call(this) || this;\r\n        _this.name = name;\r\n        _this.params = params;\r\n        _this.body = body;\r\n        return _this;\r\n    }\r\n    FunctionDeclaration.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitFunctionDeclaration(this);\r\n    };\r\n    return FunctionDeclaration;\r\n}(Statement));\r\nexports.FunctionDeclaration = FunctionDeclaration;\r\nvar ReturnStatement = /** @class */ (function (_super) {\r\n    __extends(ReturnStatement, _super);\r\n    function ReturnStatement(expression) {\r\n        var _this = _super.call(this) || this;\r\n        _this.expression = expression;\r\n        return _this;\r\n    }\r\n    ReturnStatement.prototype.accept = function (visitor) {\r\n        _super.prototype.accept.call(this, visitor);\r\n        return visitor.visitReturnStatement(this);\r\n    };\r\n    return ReturnStatement;\r\n}(Statement));\r\nexports.ReturnStatement = ReturnStatement;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/statement.ts?");

/***/ }),

/***/ "./src/equal/token.ts":
/*!****************************!*\
  !*** ./src/equal/token.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.operatorMap = exports.Token = void 0;\r\nvar Token = /** @class */ (function () {\r\n    function Token(type, line, value) {\r\n        this.tokenType = type;\r\n        this.value = value;\r\n        this.line = line;\r\n    }\r\n    return Token;\r\n}());\r\nexports.Token = Token;\r\nvar operatorMap = new Map()\r\n    .set(\"&&\", \"AND\" /* operatorType.AND */)\r\n    .set(\"||\", \"OR\" /* operatorType.OR */)\r\n    .set(\"==\", \"EQUAL\" /* operatorType.EQUAL */)\r\n    .set(\"!=\", \"NOT_EQUAL\" /* operatorType.NOT_EQUAL */)\r\n    .set(\">\", \"GREATER_THAN\" /* operatorType.GREATER_THAN */)\r\n    .set(\"<\", \"LESSER_THAN\" /* operatorType.LESSER_THAN */)\r\n    .set(\"+\", \"PLUS\" /* operatorType.PLUS */)\r\n    .set(\"-\", \"MINUS\" /* operatorType.MINUS */)\r\n    .set(\"*\", \"MULTIPLY\" /* operatorType.MULTIPLY */)\r\n    .set(\"/\", \"DIVIDE\" /* operatorType.DIVIDE */)\r\n    .set(\"!\", \"NOT\" /* operatorType.NOT */);\r\nexports.operatorMap = operatorMap;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/token.ts?");

/***/ }),

/***/ "./src/equal/utils.ts":
/*!****************************!*\
  !*** ./src/equal/utils.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.wrapValue = void 0;\r\nfunction wrapValue(val) {\r\n    if (!isNaN(Number(val)))\r\n        return Number(val);\r\n    else if (val === \"true\" || val == \"false\")\r\n        return (val === \"true\");\r\n    // val must be string\r\n    else\r\n        return val;\r\n}\r\nexports.wrapValue = wrapValue;\r\n\n\n//# sourceURL=webpack://equal/./src/equal/utils.ts?");

/***/ }),

/***/ "?1fe8":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://equal/fs_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/equal/equal.ts");
/******/ 	equal = __webpack_exports__;
/******/ 	
/******/ })()
;